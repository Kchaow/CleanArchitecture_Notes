Представим ситуацию. 
![[Pasted image 20250721184133.png]]
Каждый User использует только один свой метод и не использует другие. Несмотря на это в языках со статической типизацией изменения в методе op2 потребуют перекомпиляции OPS и следом User1, хотя User1 никак не связан с методом op2. Данную проблему может решить использование интерфейсов.
![[Pasted image 20250721184357.png]]
Кроме того в языках с динамической типизацией такой проблемы не наблюдается.
Этот факт ведет нас к заключению, что принцип разделения интерфейсов является проблемой языка, а не архитектуры.

Однако, в архитектуре в более широком смысле этот принцип встречается. Рассмотрим пример нарушения принципа разделения  интерфейсов в архитектуре. Рассмотрим, например, действия архитектора, работающеrо над системой S. Он пожелал включить в систему некоторый фреймворк F: Теперь представь те, что авторы F связали ero с поддержкой конкретной базы данных D. То есть S зависит от F, который зависит от D:
![[Pasted image 20250721184706.png]]
Теперь представьте, что D включает функции, которые не используются фреймворком F и, соответственно, не используются системой S. Изменения в этих функциях внутри D могут вынудить повторно развернуть F и, coответственно, повторно развернуть S. Хуже того, ошибка в одной из таких функций внутри D может спровоцировать появление ошибок в F и S.